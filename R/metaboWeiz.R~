#!/usr/bin/Rscript
# matchWeiz.R version="0.1"

options(stringsAsFactors = FALSE)

loadNamespace("Rdisop")
#'@importFrom fdrtool phalfnorm
#'@importFrom fdrtool sd2theta
#'@importFrom CHNOSZ makeup 
#'@importFrom CHNOSZ as.chemical.formula

run_RT_module = function (plList,polarity,mixType,project,massTol,confint=0.99) {

  print("=========================")
  print("Run RT correction module:")
  print("=========================")  
  
  data (rtReftables)
  refTable = rtReftables[[polarity]]
  
  ### function (plList,polarity,refTable,intCol1,intCol2,project,massTol,confint=0.99,massErrorSurface=NULL)

  rt.shift.model = rtModule(plList,polarity,refTable,project,massTol)
  
  if (!all(is.na(rt.shift.model))) {
    save (	
      rt.shift.model,
      file=paste (mixType,project,polarity,Sys.Date(),"Rdata",sep=".")		
    )
    print ("Saved RT shift model:")
    print (paste(mixType,project,polarity,Sys.Date(),"Rdata",sep="."))
  } else {
    print ("No RT matches - please check data manually!")
    stop ("Error - RT model cannot be built")
  }
  print ("**** RT Module - OK ****")
  return (rt.shift.model)
}

#' Match input LC-MS features to the given MS library.
#' 
#' The 'matchWeiz' multi-modular search method is applied to match the input biologically derived sample data to the 
#' given MS library. Retention time (RT) correction is first applied to the input peak list using a group of peak lists
#' originating from injections of a predefined mix of chemical standards (see \code{stdMix} data description). Several 
#' settings variables are used besides the input arguments, including exact mass values for possible adducts and the peak
#' search parameter \emph{GROUP_TH} which sets the minimum number of matches required to annotate a group of features. 
#' The output of the function is an R object containing all annotation data, which then needs to be converted to test 
#' readable format using function \code{summarizeMWresults}.
#' 
#' @param cameraPeaklist A tab delimited peak list text file, as generated by the CAMERA package.
#' @param rtCorrFiles The path to a directory containing the peak list files corresponding with a predefined mix of chemical standards (see below).
#' @param polarity The MS ionization mode (either "negative" or "positive") .
#' @param project Any descriptive name for the current search run.
#' @param MSlib MS library fileobject as generated by the \code{buildMSlibrary} function.
#' @param massTol The mass tolarance for mass-to-mass matches, in ppm (default is 20 ppm)
#' @return NULL on a succesful completion.
#' @examples
#' data(sampleLib)
#' runmatch ("tests/examples/Tom_all_negative_2ch_xan.tsv","tests/examples/rt_files_neg/","negative","tom_test",MSlib.neg)
#' runmatch ("tests/examples/Tom_all_negative_2ch_xan.tsv","tests/examples/rt_files_neg/","positive","tom_test",MSlib.pos)
#' @export
runmatch = function(
  cameraPeaklist,   
  rtCorrFiles,
  polarity, 
  project,
  MSlib,
  massTol = 20
) {    

  # RT correction mix type - at the moment this is the single option used.
  mixType ="stdMix"
  
  set.seed(0408)  
  
  ## Fix DB problem of large mass tolerance:
  if (any(range (MSlib$peaks$massTol) > 0.1)) { 
    Warning ("MS library has mass tolerance larger than 0.1 Da.")
  }
  ## 	Read sample peak list
  print ("Reading peak list file:")
  print (cameraPeaklist)
  tryCatch({
    pl = read.delim(cameraPeaklist)
  }, error=function(err) {
    stop("failed to read input sample peak list file: ", conditionMessage(err))
  })
  intCol.samp1 = min (grep(".*0[1|2]$", names(pl)))
  intCol.samp2 = max (grep(".*0[1|2]$", names(pl)))  
  # parse short sample name
  plName = strsplit(basename(cameraPeaklist),split="\\.(txt|csv|tsv)")[[1]][1]
  # remove NAs (in case fill-peaks hasn't been done)
  pl[is.na(pl[,intCol.samp1:intCol.samp2]),intCol.samp1:intCol.samp2] = abs(jitter(0))
  # compute a non-adaptive mass tolerance  values (Da.)
  pl$massTol = round(massTol*pl$mz/1e6,4)

  print ("Reading peak list file:")
  print ("rtCorrFiles")
  tryCatch({
      plList = lapply(dir(rtCorrFiles,full.names=TRUE),read.delim)
    #    plList = lapply(rtCorrFiles,read.delim)
  }, error=function(err) {
    stop("failed to read stdMix peak list file: ", conditionMessage(err))
  })
  ##
  ##  Create the RT correction model - using the rt correction module (according to previously defined model)
  ##
  rtModel = run_RT_module(plList,polarity,mixType,project,massTol)
  coeff = coef (rtModel$model)
  # Compute shifted RT 
  pl$rtShifted = pl$rt*1/coeff[2] - coeff[1]
  # Bound lower shifted RT values to minimum RT
  pl$rtShifted[pl$rtShifted<min(pl$rt)] = min(pl$rt)
  # Bound higher shifted RT values to maximum RT
  pl$rtShifted[pl$rtShifted>max(pl$rt)] = max(pl$rt)
  # Get RT search toerance from model
  rtTol = round(rtModel$CI) 
  ##
  ##	Do basic mz-rt annotation - use 'annotate feature' function:
  ##	This step returns a DB peak match(es) for each input peak according
  ##	to mz-rt match, or otherwise NULL.
  ##
  print ("Annotating individual features:")
  print (paste("RT tolerance:",rtTol,"s."))
  
  peak.annot = apply (pl[c("mz","rtShifted","massTol")],1, function(peak) {
    annotateFeature(peak,polarity,MSlib,rtTol) 
  })  
  print (paste("Matched",sum(!sapply(peak.annot,is.null)),"peaks"))
  ##
  ##	Multiple DB peak matches according to DB ids are grouped and returned in the 
  ##	slot 'grouped'. Unmatched or single-peak groups are kept in a slot: 'unmatched' 		
  ##
  if (length(peak.annot)) { 
    print ("Annotating peak groups:")
    idList = getIds(peak.annot,MSlib,pl,intCol.samp1,intCol.samp2,polarity,rtModel)
  } else {
    stop ("\nNo library matches found - please check your input data (correct ionization mode?)")
  }	
  save (idList, file=paste(project,polarity,"idList.RData",sep="_"))
  print ("Done")
  return (NULL)
}
